{"ast":null,"code":"// This will make it easier to create action objects\n// and eliminates the error of a typo for \"CHANGE\"\nexport function createChangeAction(changeBy) {\n  let actionObject = {\n    type: \"CHANGE\",\n    by: changeBy\n  };\n  return actionObject;\n} // Reducer\n// The reducer is a function that takes the previous \n// state and an action as parameters, and returns the next state. \n// Here the state of the app is defined by a count variable\n// 2 actions are present : increaseAction and decreaseAction\n// State of the app\n// Interface for the state of the app (store)\n\nconst intialState = {\n  count: 0\n};\n\nfunction counterReducer(state, action) {\n  if (state === undefined) {\n    return intialState;\n  }\n\n  switch (action.type) {\n    case \"CHANGE\":\n      {\n        return {\n          count: state.count + action.by\n        };\n      }\n\n    default:\n      return state;\n  }\n}\n\nexport default counterReducer;","map":{"version":3,"sources":["/Users/geocas/Documents/Project5CDEReact/src/redux-components/CountChanger.tsx"],"names":["createChangeAction","changeBy","actionObject","type","by","intialState","count","counterReducer","state","action","undefined"],"mappings":"AAMA;AACA;AACA,OAAO,SAASA,kBAAT,CAA4BC,QAA5B,EAAgE;AACnE,MAAIC,YAAY,GAAG;AACfC,IAAAA,IAAI,EAAE,QADS;AAEfC,IAAAA,EAAE,EAAEH;AAFW,GAAnB;AAIA,SAAOC,YAAP;AACH,C,CAED;AACA;AACA;AACA;AACA;AAEA;AACA;;AAIA,MAAMG,WAA4B,GAAG;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAArC;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA4DC,MAA5D,EAA2F;AACvF,MAAID,KAAK,KAAKE,SAAd,EAAyB;AACrB,WAAOL,WAAP;AACH;;AAED,UAAQI,MAAM,CAACN,IAAf;AACI,SAAK,QAAL;AAAe;AACX,eAAO;AAAEG,UAAAA,KAAK,EAAEE,KAAK,CAACF,KAAN,GAAcG,MAAM,CAACL;AAA9B,SAAP;AACH;;AACD;AACI,aAAOI,KAAP;AALR;AAOH;;AAED,eAAeD,cAAf","sourcesContent":["\nexport interface CounterAppAction {\n    type: string; // at this point only \"CHANGE\" is supported\n    by: number; // 1 to increase by 1, -5 to decrease by 5, etc\n}\n\n// This will make it easier to create action objects\n// and eliminates the error of a typo for \"CHANGE\"\nexport function createChangeAction(changeBy: number): CounterAppAction {\n    let actionObject = {\n        type: \"CHANGE\",\n        by: changeBy\n    }\n    return actionObject;\n}\n\n// Reducer\n// The reducer is a function that takes the previous \n// state and an action as parameters, and returns the next state. \n// Here the state of the app is defined by a count variable\n// 2 actions are present : increaseAction and decreaseAction\n\n// State of the app\n// Interface for the state of the app (store)\nexport interface CounterAppState {\n    count: number\n}\nconst intialState: CounterAppState = { count: 0 }\n\nfunction counterReducer(state: CounterAppState | undefined, action: CounterAppAction): any {\n    if (state === undefined) {\n        return intialState;\n    }\n\n    switch (action.type) {\n        case \"CHANGE\": {\n            return { count: state.count + action.by };\n        }\n        default:\n            return state;\n    }\n}\n\nexport default counterReducer;\n"]},"metadata":{},"sourceType":"module"}